package io.ia.sdk.gradle.modl.task

import io.ia.sdk.gradle.modl.PLUGIN_TASK_GROUP
import io.ia.sdk.gradle.modl.extension.ModuleDependencySpec
import io.ia.sdk.gradle.modl.model.ArtifactManifest
import io.ia.sdk.gradle.modl.model.IgnitionScope
import io.ia.sdk.gradle.modl.model.artifactManifestFromJson
import org.gradle.api.DefaultTask
import org.gradle.api.file.RegularFile
import org.gradle.api.model.ObjectFactory
import org.gradle.api.provider.MapProperty
import org.gradle.api.provider.Property
import org.gradle.api.provider.SetProperty
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.options.Option
import org.redundent.kotlin.xml.PrintOptions
import org.redundent.kotlin.xml.xml
import java.io.File
import java.io.FileNotFoundException
import javax.inject.Inject

open class WriteModuleXml @Inject constructor(_objects: ObjectFactory) : DefaultTask() {

    companion object {
        const val ID = "writeModuleXml"
    }

    init {
        this.group = PLUGIN_TASK_GROUP
        this.description = "Writes the module.xml based on values derived from plugin configuration"
    }

    @get:Input
    val freeModule: Property<Boolean> = _objects.property(Boolean::class.javaObjectType)

    @get:Input
    val moduleDescription: Property<String> = _objects.property(String::class.java)

    @get:Input
    val moduleId: Property<String> = _objects.property(String::class.java)

    @get:Input
    val moduleName: Property<String> = _objects.property(String::class.java)

    @get:Input
    val moduleVersion: Property<String> = _objects.property(String::class.java)

    @get:Input
    val requiredIgnitionVersion: Property<String> = _objects.property(String::class.java)

    /**
     * Hook classes, as provided by the module settings extension object.  class Reference : scope
     */
    @get:Input
    val hookClasses: MapProperty<String, String> = _objects.mapProperty(String::class.java, String::class.java)

    /**
     * Manifests files generated by the [CollectModlDependencies.manifestFile] output file property
     */
    @get:InputFiles
    val artifactManifests: SetProperty<RegularFile> = _objects.setProperty(RegularFile::class.java)

    @get:Input
    val requireFromPlatform: MapProperty<String, String> =
        _objects.mapProperty(String::class.java, String::class.java)

    @get:Input
    val requiredFrameworkVersion: Property<String> = _objects.property(String::class.java)

    /**
     * Path to license file, optionally provided by user.
     */
    @get:Optional
    @get:Input
    val license: Property<String> = _objects.property(String::class.java)

    /**
     * Map of <moduleId : scope>
     */
    @get:Input
    @get:Optional
    @Deprecated("Use new moduleDependencySpecs")
    val moduleDependencies: MapProperty<String, String> =
        _objects.mapProperty(String::class.java, String::class.java)

    /**
     * Structured replacement for [moduleDependencies], including moduleId,
     * scope, and whether the gateway should tolerate whether each dependency
     * loads or not prior to loading the current module.
     */
    @get:Input
    @get:Optional
    val moduleDependencySpecs: SetProperty<ModuleDependencySpec> =
        _objects.setProperty(ModuleDependencySpec::class.java)

    @get:Input
    @get:Optional
    val docIndexPath: Property<String> = _objects.property(String::class.java)

    /**
     * Whether to fold and sort duplicate jars dependencies when the same appear
     * in more than one scope.
     *
     * Also converts implicit all scope string 'CDG' to 'A' and sorts jars by
     * scope string.
     *
     * Default is `false`.
     */
    @get:Input
    @get:Optional
    @Option(
        description = "Folds jars from multiple scopes into a single jar entry."
    )
    val foldJars: Property<Boolean> = _objects.property(Boolean::class.java)
        .convention(false)

    @OutputFile
    fun getModuleXmlFile(): File {
        return project.file("${project.buildDir}/moduleContent/module.xml")
    }

    init {
        this.description = "Writes the module.xml file for the module, using the settings applied to the " +
            "'ignitionModule' block of the build script."
        this.group = "Ignition Module"
    }

    @TaskAction
    fun execute() {

        val xml = buildXml()
        val fileToWrite = getModuleXmlFile()
        project.logger.debug("Beginning to write to '${fileToWrite.absolutePath}' with content:\n$xml")

        writeXml(fileToWrite, xml)
    }

    private fun buildXml(): String {
        val modules = xml("modules", "UTF-8") {
            "module" {
                "name" { -moduleName.get() }

                "id" { -moduleId.get() }

                "version" { -moduleVersion.get() }

                "description" { -moduleDescription.get() }

                if (license.isPresent && license.get().isNotEmpty()) {
                    val licenseFile: File = project.file(license.get())

                    if (licenseFile.exists()) {
                        "license" {
                            -licenseFile.name
                        }
                    } else {
                        throw FileNotFoundException("Could not find license file ${licenseFile.absolutePath}")
                    }
                }

                if (requiredIgnitionVersion.isPresent) {
                    "requiredIgnitionVersion" {
                        -requiredIgnitionVersion.get()
                    }
                }

                "freeModule" {
                    -freeModule.get().toString()
                }

                if (docIndexPath.isPresent) {
                    "documentation" { -docIndexPath.get() }
                }

                hookClasses.get().forEach { classReference, scope ->
                    "hook" {
                        attribute("scope", scope)
                        -classReference
                    }
                }

                if (moduleDependencySpecs.isPresent && moduleDependencySpecs.get().isNotEmpty()) {
                    moduleDependencySpecs.get().forEach { dependency ->
                        "depends" {
                            attribute("scope", dependency.scope)
                            if (usemoduleDependencySpecs()) attribute("required", dependency.required)
                            -dependency.name
                        }
                    }
                } else if (moduleDependencies.isPresent) {
                    moduleDependencies.get().forEach { moduleId, scope ->
                        "depends" {
                            attribute("scope", scope)
                            -moduleId
                        }
                    }
                }

                requireFromPlatform.get().forEach { libraryName, scope ->
                    "require" {
                        attribute("scope", scope)
                        -libraryName
                    }
                }

                if (requiredFrameworkVersion.isPresent && requiredIgnitionVersion.get().isNotEmpty()) {
                    "requiredFrameworkVersion" {
                        -requiredFrameworkVersion.get()
                    }
                }

                manifests().forEach { (jarName, scope) ->
                    "jar" {
                        attribute("scope", scope)
                        -jarName
                    }
                }
            }
        }

        return modules.toString(PrintOptions(pretty = true, singleLineTextElements = true, useSelfClosingTags = false))
    }

    private fun usemoduleDependencySpecs(): Boolean {
        if (!requiredIgnitionVersion.isPresent) return false

        val version = requiredIgnitionVersion.get().split(".").map { it.toInt() }
        if (version[0] >= 9) { return true }
        if (version[0] == 8 && version[1] >= 3) { return true }
        return false
    }

    // Manifests' artifacts
    private fun manifests(): List<Pair<String, String>> =
        artifactManifests.get().map { manifest ->
            artifactManifestFromJson(manifest.asFile.readText(Charsets.UTF_8))
        }.let { manifests ->
            if (foldJars.get())
            // more compact or else legacy dup-prone
                deduplicatedJars(manifests) else rawScopedJars(manifests)
        }

    // Collapse duplicate artifacts in different scopes to single scope string.
    //
    // IGN-10168 is backlogged to handle at least some of this upstream,
    // probably in or near `collectModlDependencies`.
    private fun deduplicatedJars(
        manifests: List<ArtifactManifest>
    ): List<Pair<String, String>> =
        manifests
            .flatMap { mani -> mani.artifacts }
            .groupBy { arti -> arti.jarName }
            .map { (jar, artifacts) ->
                val combinedScope = artifacts.fold(setOf<Char>()) { scope, arti ->
                    scope.union(
                        manifests
                            .filter { mani -> arti in mani.artifacts }
                            .flatMap { mani -> mani.scope.toList() }
                    )
                }.joinToString("")
                    .let { scope ->
                        // CDG > A formalized b/c we'll want it for IGN-10168
                        IgnitionScope.promoteToAllWhenImplied(scope).code
                    }

                jar to combinedScope
            }.sortedWith(
                compareByDescending<Pair<String, String>> { (_, scope) -> scope.length }
                    .thenBy { (_, scope) -> scope }
                    .thenBy { (jar, _) -> jar }
            )

    // Leave duplicate artifacts largely as-is, even if present in 2+ scopes.
    // This is legacy behavior.
    private fun rawScopedJars(
        manifests: List<ArtifactManifest>
    ): List<Pair<String, String>> =
        manifests
            .groupBy { mani -> mani.scope }
            .map { (scope, manis) ->
                val distinctJars =
                    manis
                        .flatMap { mani -> mani.artifacts }
                        .fold(mutableSetOf<String>()) { jars, arti ->
                            jars.apply { add(arti.jarName) }
                        }

                scope to distinctJars
            }.fold(mutableListOf<Pair<String, String>>()) { lst, (scope, jars) ->
                lst.apply {
                    addAll(
                        jars.map { jar -> jar to scope }
                    )
                }
            }

    fun writeXml(outputFile: File, moduleXml: String) {
        outputFile.writeText(moduleXml)
    }
}
